### Interview Callenge Questions ###

# Question 1
My solution for this question strives for minimal code and maximal simplicity. I first check the data type of the input string 's' and sub-string 't' to ensure that only strings will be processed by the function. If 's' and 't' are strings, I chose to use the 'in' operator to determine if each character in 't' can be found in 's'. Simplicity is the main reason for using the 'in' operator to find 't' is 's'. The 'in' operator must iterate through each character in 's' and therefore has time compexity of O(n) where 'n' is the number of characters in 's'. The question1 solution also contains a 'for' loop to iterate through each character in 't' which has a time complexity of O(m) where 'm' is the number of characters in 't'. With these two different loops, the overall time complexity of question1 is O(nm). The function only allocates memory to the input variables and one
local variable making the space complexity O(1).


# Question 2
My solution for question 2 uses two loops to parse the input string 'a' and determine the length of any palendromic sub-strings. The first loop is a 'for' loop that iterates over the input string and has a time complexity of O(n) where 'n' is the number of characters in 'a'. If a palendromic sub-string is found, a 'while' loop searches outward to find the extext of the palendrome. The while loop has a time complexity of O(n) in the worst case where the entre string is a palendrome. The overall time complexity in the worst case comes out to be O(n^2). The palendrome sub-string has the potential to be as large as the input string, and therefore has a space complexity of O(n) in the wost case.


# Question 3
My solution to question 3 leverages instantiating Edge, Node, and Graph objects to improve readability of the solution. When solving question 3, three functions come into play, `mst()`, `get_adjacency_dict()`, and `question3()`. The `mst()` function uses the built in `sorted()` function to arrange the graph edges from smallest to largest. This operation has a time complexity of O(e) where 'e' is the number of edges. The `mst()` function also contains a 'while' loop to add nodes to the minimum spanning tree. The 'while' loop continues until either all nodes have been added or the list of edges has been exhausted. Inside this loop the list of edges becomes shorter as the MST grows by way of the built-in `del` function. The `del` function has a time complextiy of O(e) in the worst case. Overall, this loop a time complexity of O(e^2). To summarize, the `mst()` function has a worst-case time complexity of O(e^2).

The `get_adjacency_dict()` function contains a single 'for' loop to rearrange the data in the MST graph into an adjacency dictionary. This straight-forward 'for' loop has a time complexity of O(n) where 'n' is the number of nodes. This function has a slightly different complexity than `mst()` becasue `mst()` runs for each edge in the graph, while `get_adjacency_dict()` runs for each node and there can be greater or fewer edges than nodes.

Finally, the `question3()` function begins by building a Graph object by iterating over each item in the input adjacency list. This loop will run for each node in the input graph, which will have the same number of nodes as in the `get_adjacency_dict()` function. For this reason, the `question3()` incurs a time complextiy of O(n). Overall, the solution to question 3 will have a time complextiy of O(n*e^2). Question 3 instanciates a Node object for each node in the graph, an Edge object for each edge, and two Graph objects which are essentially containers for the nodes and edges. The space complexity simplifies down to O(en).


# Question 4
The solution to question 4 that I propose also uses objects to simplify complexity of traversing a Binary Search Tree. The `question4()` function begins by building the BST by iterating over the rows in the input matrix and iterating over indicies in each row. This iteration incurs a time complexity of O(m^2) where m is the lenght of one dimension of the square matrix. Two ancesty lists are built for nodes 'n1' and 'n2' using the `search()` function. `search()` is a recursive function that traverses the BST with a time complexity of O(log(n)) where 'n' is the number of nodes in the tree. The complexity of the two `search()` functions reduces to O(log(n)). A final 'for' loop is run in the `question4()` function to identify where the ancestry of 'n1' and 'n2' diverge. This loop can be represented by O(a) where 'a' is the length of one of the ancestry lists. To summarize question 4, the overall time complexity comes down to O(log(n)*m^2). The significant space complexity in question 4 comes from the two ancestry lists generated by `search()`. This space complexity can be represented by O(a) where 'a' is the length of the list.


# Question 5
My solution to question 5 makes use of Node and Linked List objects to simplify searching the list. The `question5()` function calls two functions that iterate over the linked list, `length()` and `get_position()`. The `length()` function is called to determine to total length of the list to then calculate which node is being specified by 'm'. `length()` iterates over each node in the list and incurs a time complexity of O(n) where n is the number of nodes in the list. The `get_position()` function is used to get the node at position 'm' and must iterate over each node up to 'm'. This function has a time complexity of O(n) in the worst case. The simplified time complexity of question 5 comes to O(n). The space complexity simplifies to O(1) because `question5()` only stores a few integers in variables.